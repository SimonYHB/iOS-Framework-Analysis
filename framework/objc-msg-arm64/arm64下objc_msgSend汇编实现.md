    0x18378c420 <+0>:   cmp    x0, #0x0                  ; =0x0 
    0x18378c424 <+4>:   b.le   0x18378c48c               ; <+108>
    // x0->self #0x0->0 将self于0进行有符号比较(cmp)，如果self不大于0(b.le:判断小于等于并跳转)则跳转到0x18378c48c
    0x18378c428 <+8>:   ldr    x13, [x0]
    // 将x0存放的self的isa地址加载到x13寄存器中。(ldr:将存储器地址 所指地址处连续的4个字节（1个字）的数据传送到目的寄存器中)
    0x18378c42c <+12>:  and    x16, x13, #0xffffffff8
    // 将isa和#0xffffffff8进行按位与(and)运算，并将结果存到x13中。(arm64架构使用non-pointer isa技术，isa字段除了包含指向Class信息，还存储了其他信息，例如引用计算等，进行按位与计算去除低位的冗余信息，最终得到Class的地址)
    0x18378c430 <+16>:  ldp    x10, x11, [x16, #0x10]
    // 将Class地址偏移16字节(#0x10)后，向后取2个8字节分别放入x10和x11寄存器中，其中x10存放_buckets哈希桶，x11的高32位存放_occupied，低32位存放_mask。（ldp:与ldr类似，都是取值指令，可以连续取多个)
    0x18378c434 <+20>:  and    w12, w1, w11
    // 将x1存放的_cmd的低32位信息和x11存放的低32位_mask信息进行按位与(相当于_cmd%table_size)得到哈希桶中的索引，并保存到x12的低32位中。(x1->寄存器的全部64位值，w1->寄存器的低32位值)
    0x18378c438 <+24>:  add    x12, x10, x12, lsl #4
    // 将x12中的索引值左移4位(lsl #4)，得到16位的索引值后(哈希桶中的bucket都是16位),与x10存放的哈希桶首地址相加(add)得到对应bucket地址存入x12中。
    0x18378c43c <+28>:  ldp    x9, x17, [x12]
    // 将x12中bucket对应的2个8字节信息存放到x9和x17中，bucket是由selector和IMP两部分组成，x9存放selector，x17存放IMP
    0x18378c440 <+32>:  cmp    x9, x1
    0x18378c444 <+36>:  b.ne   0x18378c44c               ; <+44>
    // 将x1和x9存放的selector进行比较，如果不相同(b.ne)则跳转到0x18378c44c执行
    0x18378c448 <+40>:  br     x17
    // 跳转(br)到x17存放的IMP执行具体代码。(**此时objc_msgSend处理最快的路径已经结束，既方法调用已经被缓存到哈希桶中，找到在对应的哈希桶中位置并执行)
    0x18378c44c <+44>:  cbz    x9, 0x18378c720           ; _objc_msgSend_uncached
    // x1和x9存放的selector不相同时会执行到该执行，判断x9是否为0(cbz)，为0则跳转到0x18378c720(对应代码为_objc_msgSend_uncached)。x9为0时表示对应的selector没有被缓存到哈希桶中，需要跳转到_objc_msgSend_uncached去执行没有缓存的查找方法(C函数)。
    0x18378c450 <+48>:  cmp    x12, x10
    0x18378c454 <+52>:  b.eq   0x18378c460               ; <+64>
    // 将当前x12中的bucket地址与x10中的哈希桶首地址进行比较，如果相同则跳转到0x18378c460，从表位进行反向查询，不相同说明不是在表头，继续往下执行
    0x18378c458 <+56>:  ldp    x9, x17, [x12, #-0x10]!
    0x18378c45c <+60>:  b      0x18378c440               ; <+32>
    // 往后偏移16位(#-0x10)x12中的bucket(#-0x10)得到新的bucket写入x12中(!)，并存放到x9(selector)和x17(IMP)中。
    // 接着跳回0x18378c440循环执行x1和x9比较等操作，直到找到匹配项、bucket为空或回到哈希桶的表头
    0x18378c460 <+64>:  add    x12, x12, w11, uxtw #4
    // 当找到匹配项或回到哈希桶的表头会执行到该指令，此时x12为最新的bucket地址，将w11左移4位(uxtw #4)后和x12相加得到哈希桶表尾地址，并将表尾地址存放到x12中
    0x18378c464 <+68>:  ldp    x9, x17, [x12]
    // 将表位的bucket信息存储到x9和x17中
    0x18378c468 <+72>:  cmp    x9, x1
    0x18378c46c <+76>:  b.ne   0x18378c474               ; <+84>
    0x18378c470 <+80>:  br     x17
    // 比较x1和x9的selector是否相同，不相同则跳转到0x18378c474，相同则跳到x17的IMP位置执行
    0x18378c474 <+84>:  cbz    x9, 0x18378c720           ; _objc_msgSend_uncached
    // 同0x18378c44c，判断x9是否为0，为0则执行_objc_msgSend_uncached
    0x18378c478 <+88>:  cmp    x12, x10
    0x18378c47c <+92>:  b.eq   0x18378c488               ; <+104>
    // 判断x12与x10地址是否相同，相同则说明已循环完整个哈希桶，没有找到对应的bucket，跳转到0x18378c488
    0x18378c480 <+96>:  ldp    x9, x17, [x12, #-0x10]!
    0x18378c484 <+100>: b      0x18378c468               ; <+72>
    // 与0x18378c458指令相同，将bucket往后偏移16位后跳转0x18378c468，循环匹配bucket
    0x18378c488 <+104>: b      0x18378c720               ; _objc_msgSend_uncached
    // 该指令会出现在内存损坏，既有索引值却找不到对应的bucket
    //-----------至此，前半部分在哈希桶中循环查找selector结束-----
    0x18378c48c <+108>: b.eq   0x18378c4c4               ; <+164>
    // 开头0x18378c424执行后，self不大于0时会执行该指令，其中小于0则为标记指针(Tagged Pointer)，等于0位nil。该指令判断是否等于nil，为nil为跳转到0x18378c4c4。
    0x18378c490 <+112>: mov    x10, #-0x1000000000000000
    // 将#-0x1000000000000000(高4位为1，其他为0的整型值)写入x10寄存器，用于作为提取self标记为的掩码
    0x18378c494 <+116>: cmp    x0, x10
    0x18378c498 <+120>: b.hs   0x18378c4b0               ; <+144>
    // 比较x0中的self和x10中的掩码，如果self大于等于(h.hs)掩码，意味self的高4位也都为1，说明是自定义扩展的Tagged Pointer类型对象，第52-59位存储了Tagged Pointer类数组的索引值，跳转到0x18378c4b0处理，否则是系统自带的Tagged Pointer类型对象，高4位存储了Tagged Pointer类数组的索引值，继续往下执行
    0x18378c49c <+124>: adrp   x10, _objc_debug_taggedpointer_classes@PAGE
    0x18378c4a0 <+128>: add    x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF
    // adrp和add指令用于加载tagged pointer主表(_objc_debug_taggedpointer_classes@PAG)到x10中，因为 ARM64 上的指针是 64 位宽，而指令只有 32 位宽，所以需要采用类 RISC 标准技术通过两个指令来加载符号地址。adrp 指令加载高 32 位信息然后再通过 add 指令将其与低 32 位进行求和。
    0x18378c4a4 <+132>: lsr    x11, x0, #60
    // 将x0右移(lsr)60位置得到存储在self高4位的索引值，并保存到x11中。
    0x18378c4a8 <+136>: ldr    x16, [x10, x11, lsl #3]
    // 通过x10的表头地址加上索引值(x11<<3)获取指针的类信息存储到x16中
    0x18378c4ac <+140>: b      0x18378c430               ; <+16>
    // 跳转回0x18378c430进行方法查询处理
    0x18378c4b0 <+144>: adrp   x10, _objc_debug_taggedpointer_ext_classes@PAGE
    0x18378c4b4 <+148>: add    x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF
    // 该指令是0x18378c498中self为展的Tagged Pointer类型对象处理，此时与上面加载主表操作类似，加载拓展表
    0x18378c4b8 <+152>: ubfx   x11, x0, #52, #8
    // 提取self第52位~59位存储到x11中。
    0x18378c4bc <+156>: ldr    x16, [x10, x11, lsl #3]
    // 通过x10的表头地址加上索引值(x11<<3)获取指针的类信息存储到x16中
    0x18378c4c0 <+160>: b      0x18378c430               ; <+16>
    // 跳转回0x18378c430进行方法查询处理

    0x18378c4c4 <+164>: mov    x1, #0x0
    0x18378c4c8 <+168>: movi   d0, #0000000000000000
    0x18378c4cc <+172>: movi   d1, #0000000000000000
    0x18378c4d0 <+176>: movi   d2, #0000000000000000
    0x18378c4d4 <+180>: movi   d3, #0000000000000000
    0x18378c4d8 <+184>: ret    
    // self为nil的处理指令，在arm64下，函数整型的返回值会存在x0,x1中，而浮点数的返回值存在v1-v3中，由于不知道函数的调用者需要什么类型，因此会将上述寄存器都清空，x0已经是0了，因此不需要清空。
    0x18378c4dc <+188>: nop    
